import pygame
# import sys

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
RED = (255, 0, 0)

# Create the screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('2D Platformer')

# Load background image
original_background = pygame.image.load('background.png').convert()

background = pygame.transform.scale(original_background, (800, 600))

original_player_image = pygame.image.load('knight.png').convert_alpha()
player_image = pygame.transform.scale(original_player_image, (50, 50))

# Define the player object


class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((50, 50))
        self.image.fill(BLUE)
        # self.image = player_image
        self.rect = self.image.get_rect()
        self.rect.x = 100
        self.rect.y = 500
        self.change_x = 0
        self.change_y = 0
        self.jump_count = 10

    def update(self):
        self.calc_grav()
        self.rect.x += self.change_x

        # Цей код використовується для того, щоб уникнути проникнення гравця в платформу при русі гравця вправо або вліво.
        # Check for collision with platforms
        block_hit_list = pygame.sprite.spritecollide(self, platforms, False)
        for block in block_hit_list:
            if self.change_x > 0:
                """ Якщо умова виконується, то правий край прямокутника гравця (який представлений за 
                допомогою self.rect) встановлюється на лівий край прямокутника блоку block, з яким 
                гравець зіткнувся. Це відбувається для того, щоб уникнути проникнення гравця в блок. """
                self.rect.right = block.rect.left
            elif self.change_x < 0:
                """  Якщо умова виконується, то лівий край прямокутника гравця встановлюється на 
                правий край прямокутника блоку block, з яким гравець зіткнувся. """
                self.rect.left = block.rect.right

        self.rect.y += self.change_y

        # Цей код використовується для того, щоб уникнути проникнення гравця в платформу при русі гравця вверх або вниз.
        # Check for collision with platforms
        block_hit_list = pygame.sprite.spritecollide(self, platforms, False)
        for block in block_hit_list:
            if self.change_y > 0:
                self.rect.bottom = block.rect.top
            elif self.change_y < 0:
                self.rect.top = block.rect.bottom

            self.change_y = 0

    """ метод calc_grav використовується для моделювання гравітації, яка впливає на 
    рух гравця вниз, і обробляє випадки, коли гравець досягає дна екрану. """

    def calc_grav(self):
        """ Якщо change_y (зміна позиції по вертикалі) дорівнює нулю, це означає, що гравець ще не почав падати.
        Тому change_y встановлюється на значення 1, щоб почати рух вниз. """
        if self.change_y == 0:
            self.change_y = 1
        else:
            """ В іншому випадку (якщо change_y не дорівнює нулю), до значення change_y додається гравітаційне
            прискорення (0.35 у даному випадку), що змінює change_y, щоб гравець поступово прискорював свій падіння вниз. """
            self.change_y += .35

        if self.rect.y >= SCREEN_HEIGHT - self.rect.height and self.change_y >= 0:
            self.change_y = 0
            self.rect.y = SCREEN_HEIGHT - self.rect.height

    def jump(self):
        self.rect.y += 2
        platform_hit_list = pygame.sprite.spritecollide(self, platforms, False)
        self.rect.y -= 2

        if len(platform_hit_list) > 0 or self.rect.bottom >= SCREEN_HEIGHT:
            self.change_y = -10

    def go_left(self):
        self.change_x = -6

    def go_right(self):
        self.change_x = 6

    def stop(self):
        self.change_x = 0

# Define the platform object


class Platform(pygame.sprite.Sprite):
    def __init__(self, width, height, x, y):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(GREEN)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

# Define the collectible object


class Collectible(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((20, 20))
        self.image.fill(YELLOW)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

# Define the enemy object


class Enemy(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((40, 40))
        self.image.fill(RED)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y


# Initialize player
player = Player()
all_sprites = pygame.sprite.Group()
all_sprites.add(player)

# Initialize platforms
platforms = pygame.sprite.Group()
platform_list = [
    Platform(200, 20, 100, 500),
    Platform(200, 20, 400, 400),
    Platform(200, 20, 100, 300),
    Platform(200, 20, 400, 200),
]

for platform in platform_list:
    platforms.add(platform)
    all_sprites.add(platform)

# Initialize collectibles
collectibles = pygame.sprite.Group()
collectible_list = [
    Collectible(150, 450),
    Collectible(450, 350),
    Collectible(150, 250),
    Collectible(450, 150),
]
for collectible in collectible_list:
    collectibles.add(collectible)
    all_sprites.add(collectible)

# Initialize enemies
enemies = pygame.sprite.Group()
enemy_list = [
    Enemy(300, 500),
    Enemy(300, 300),
]
for enemy in enemy_list:
    enemies.add(enemy)
    all_sprites.add(enemy)

# Main game loop
running = True
clock = pygame.time.Clock()

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                player.go_left()
            elif event.key == pygame.K_RIGHT:
                player.go_right()
            elif event.key == pygame.K_SPACE or event.key == pygame.K_UP:
                player.jump()
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT or event.key == pygame.K_RIGHT:
                player.stop()

    # Update all sprites
    all_sprites.update()

    # Check for collisions with collectibles
    collectible_hit_list = pygame.sprite.spritecollide(
        player, collectibles, True)

    # Check for collisions with enemies
    enemy_hit_list = pygame.sprite.spritecollide(player, enemies, False)

    if enemy_hit_list:
        running = False  # End the game if player collides with an enemy

    # Draw everything
    screen.blit(background, (0, 0))
    all_sprites.draw(screen)

    # Flip the screen
    pygame.display.update()

    # Limit to 60 frames per second
    clock.tick(60)

pygame.quit()
# sys.exit()
